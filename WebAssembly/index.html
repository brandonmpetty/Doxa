<!doctype html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
		<title>Δoxa Binarization Framework - WebAssembly Demo</title>

		<!--
		https://www.w3schools.com/howto/howto_js_image_comparison.asp
		Copyright 1999-2019 by Refsnes Data
		https://www.w3schools.com/about/about_copyright.asp
		"Copying examples and code snippets for non-profit teaching and research."
		The code has been slightly altered for my needs. - Brandon Petty
		-->
		<link rel="stylesheet" type="text/css" href="w3schoolImgCompare.css">
		<script type="text/javascript" src="w3schoolImgCompare.js"></script>
		<style>
			.algInput {
				padding-right: 10px;
				display: none;
			}
			#perf-section {
				display: none;
			}
			#perf-section label {
				padding-left: 10px;
			}
			#workspace {
				display: none;
			}
			
			#loader {
				position: absolute;
				left: 50%;
				top: 50%;
				z-index: 1;
				width: 150px;
				height: 150px;
				margin: -75px 0 0 -75px;
				border: 16px solid #f3f3f3;
				border-radius: 50%;
				border-top: 16px solid #3498db;
				width: 120px;
				height: 120px;
				-webkit-animation: spin 2s linear infinite;
				animation: spin 2s linear infinite;
			}

			@-webkit-keyframes spin {
				0% { -webkit-transform: rotate(0deg); }
				100% { -webkit-transform: rotate(360deg); }
			}

			@keyframes spin {
				0% { transform: rotate(0deg); }
				100% { transform: rotate(360deg); }
			}
		</style>
	</head>
	<body>
	<center>
	<h1>WebAssembly Demo - Local Adaptive Binarization</h1>
	This is an <b>experimental</b> project that exposes the ΔBF, written in C++, to JavaScript via WebAssembly.<br/>
	<a href="https://github.com/brandonmpetty/Doxa">https://github.com/brandonmpetty/Doxa</a><br/>
	<br/><br/>
	
	<div id="loader"></div>
	<div id="workspace" style="display: table; visibility: hidden; max-width: 700px;">
		<div style="padding-bottom: 10px; text-align: left;">
			<label for="algorithm" style="padding-right: 10px;">Algorithm:
				<select id="algorithm" onchange="selectAlgorithm(this.value);">
				</select>
			</label>
			
			<label for="windowSize" class="algInput">Window Size:
				<input type="number" id="window-el" name="windowSize"
					min="1" max="500" value="75" step="2" style="width: 4em">
			</label>
			
			<label for="kValue" class="algInput">K Value:
				<input type="number" id="k-el" name="kValue"
					min="-5.00" max="5.00" value="0.20" step="0.01" style="width: 5em">
			</label>
			
			<label for="threshold" class="algInput">Threshold:
				<input type="number" id="threshold-el" name="threshold"
					min="0" max="255" value="100" step="1" style="width: 4em">
			</label>
			
			<label for="contrastLimit" class="algInput">Contrast Limit:
				<input type="number" id="contrast-limit-el" name="contrastLimit"
					min="0" max="255" value="25" step="1" style="width: 4em">
			</label>

			<label for="minN" class="algInput">Min. High-Contrast Pixels:
				<input type="number" id="minN-el" name="minN"
					min="1" max="500" value="75" step="1" style="width: 4em">
			</label>

			<label for="RValue" class="algInput">R Value:
				<input type="number" id="R-el" name="RValue"
					min="-5.00" max="5.00" value="1.00" step="0.01" style="width: 5em">
			</label>
			
			<button id="apply" type="button" onclick="canvasToBinary();">Apply</button>
		</div>
		<div style="padding-bottom: 10px; text-align: left;">
			<label for="performance" style="vertical-align: top;">
				<input name="performance" id="performance" type="checkbox" onclick="togglePerformance();" style="vertical-align: top;"/>
				Analyze
			</label>
			
			<span id="perf-section">
				<label for="accuracy">Accuracy:
					<span id="accuracy"></span>
				</label>
				
				<label for="fmeasure">F-Measure:
					<span id="fmeasure"></span>
				</label>
				
				<label for="psnr">PSNR:
					<span id="psnr"></span>
				</label>
				
				<label for="nrm">NRM:
					<span id="nrm"></span>
				</label>
				
				<label for="drdm">DRDM:
					<span id="drdm"></span>
				</label>
				<div>
					<label for="time">Binarization Time:
						<span id="time"></span> ms
					</label>
				</div>
			</span>
		</div>
		<div class="img-comp-container">
			<div class="img-comp-img">
				<canvas id="binaryCanvas">
					Sorry. Your browser does not support HTML5 canvas element.
				</canvas>
			</div>
			<div class="img-comp-img img-comp-overlay">
				<canvas id="sourceCanvas">
					Sorry. Your browser does not support HTML5 canvas element.
				</canvas>
			</div>
		</div>
		<div style="padding-top: 10px; text-align: left;">
			Author(s): <span id="authors"></span><br/>
			Citation: <span id="citation" /></span>
		</div>
		<canvas id="groundTruthCanvas" style="display: none;">
			Sorry. Your browser does not support HTML5 canvas element.
		</canvas>
	</div>
	</center>
	
	
	<script type="text/javascript">
		let srcCanvas;
		let dstCanvas;
		let srcImage;
		let dstImage;
		let gtImage;
		let currentAlgorithm;
		let algorithms = [];
		let time;
	
		async function loadCanvas(canvas, src) {

			return new Promise((resolve, reject) => {

				// Load image into canvas using onload callback
				const img = new Image();
				img.onerror = function() {
					reject();
				};
				img.onload = function() {
					const ctx = canvas.getContext('2d');

					canvas.width = img.width;
					canvas.height = img.height;
					ctx.drawImage(img, 0, 0);

					resolve();
				};

				img.src = src;
			});
		}

		function readCanvas(canvas) {

			const ctx = canvas.getContext('2d');
			const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
			return new Doxa.Image(imageData.width, imageData.height, imageData.data);
		}
		
		function canvasToBinary() {
			// Get params from UI and update selected object algorithm
			for (const key in currentAlgorithm.params) {
				const el = document.getElementById(key+'-el');
				currentAlgorithm.params[key] = Number(el.value);
			}
		
			// Performance speed test
			const timer = performance.now();
		
			try {
				// Convert to Binary
				dstImage = Doxa.Binarization.toBinary(
					currentAlgorithm.enum, 
					srcImage, 
					currentAlgorithm.params, 
					dstImage); // If the first call, allocate memory.  All other calls use the allocated memory.
			}
			catch(ex) {
				console.dir(ex);
			}

			// Calculate time in milliseconds
			time = performance.now() - timer;
			
			// Draw to Canvas
			dstImage.draw(dstCanvas);
			
			// Analyze performance after binarization
			if (document.getElementById('performance').checked && gtImage) {
				calculatePerformance();
			}
		}
		
		async function togglePerformance() {
			// Toggle
			document.getElementById('perf-section').style.display = 
				document.getElementById('performance').checked ? "inline-block" : "none";
		
			// Do not init if already loaded
			if (gtImage) return;
		
			// Load the ground truth and calculate
			await loadCanvas(gtCanvas, '../Images/2JohnC1V3-GroundTruth.png');
			gtImage = readCanvas(gtCanvas);

			// Since this is the first load, calculate it
			calculatePerformance();
		}
		
		function calculatePerformance() {
			const performance = Doxa.Binarization.calculatePerformance(gtImage, dstImage);
			
			// Performance
			document.getElementById('accuracy').innerHTML = performance.accuracy.toFixed(4);
			document.getElementById('fmeasure').innerHTML = performance.fm.toFixed(4);
			document.getElementById('psnr').innerHTML = performance.psnr.toFixed(4);
			document.getElementById('nrm').innerHTML = performance.nrm.toFixed(4);
			document.getElementById('drdm').innerHTML = performance.drdm.toFixed(4);
			
			// Speed
			document.getElementById('time').innerHTML = time.toFixed(2);
		}
		
		function initializeAlgorithm() {		
			// Update Authorship
			document.getElementById('authors').textContent = currentAlgorithm.authors;
			document.getElementById('citation').textContent = currentAlgorithm.title + " : " + currentAlgorithm.date;
			
			// On initial select, convert to binary
			canvasToBinary();
		}
		
		function initializeInputs() {
			// Hide Apply button if there are no keys, else show it
			document.getElementById('apply').style.display = 
				Object.keys(currentAlgorithm.params).length === 0 ? 'none' : 'inline-block';
		
			// Hide all input elements
			let divsToHide = document.getElementsByClassName("algInput");
			for(let i = 0; i < divsToHide.length; ++i){
				divsToHide[i].style.display = 'none';
			}
			
			// Set all algorithm defaults based on algorithm parameters
			for (let key in currentAlgorithm.params) {
				let el = document.getElementById(key+'-el');
				el.value = currentAlgorithm.params[key];
				el.parentElement.style.display = 'inline-block';
			}
		}
		
		function selectAlgorithm(algorithm) {
			// The order of this call does matter since we are dealing with a global.
			currentAlgorithm = algorithms[algorithm];
			
			initializeInputs();
			initializeAlgorithm();
		}
		
		function loadAlgorithms(algorithEnums) {
			// Set available algorithms
			algorithms[algorithEnums.OTSU] = { 
				name: 'Otsu', 		params: {}, enum: algorithEnums.OTSU,
				date: 1979, title: 'A threshold selection method from gray-level histograms', authors: 'Nobuyuki Otsu'};
			algorithms[algorithEnums.BERNSEN] = { 
				name: 'Bernsen', 	params: { window: 75, threshold: 100, 'contrast-limit': 25 }, enum: algorithEnums.BERNSEN,
				date: 1986, title: 'Dynamic thresholding of gray-level images', authors: 'John Bernsen'};
			algorithms[algorithEnums.NIBLACK] =	{
				name: 'Niblack', 	params: { window: 223, k: -0.61 }, enum: algorithEnums.NIBLACK,
				date: 1986, title: 'An Introduction to Digital Image Processing', authors: 'Wayne Niblack'};
			algorithms[algorithEnums.SAUVOLA] =	{
				name: 'Sauvola', 	params: { window: 26, k: 0.10 }, enum: algorithEnums.SAUVOLA,
				date: 1999, title: 'Adaptive document image binarization', authors: 'J. Sauvola, M. Pietikäinen'};
			algorithms[algorithEnums.WOLF] =	{
				name: 'Wolf', 		params: { window: 20, k: 0.18 }, enum: algorithEnums.WOLF,
				date: 2003, title: 'Extraction and Recognition of Artificial Text in Multimedia Documents', authors: 'Christian Wolf, Jean-Michel Jolion'};
			algorithms[algorithEnums.NICK] =	{
				name: 'N.I.C.K.', 	params: { window: 44, k:-0.10 }, enum: algorithEnums.NICK,
				date: 2009, title: 'Comparison of Niblack inspired Binarization methods for ancient documents', authors: 'Khurram Khurshid, Imran Siddiqi, Claudie Faure, Nicole Vincent'};
			algorithms[algorithEnums.ADOTSU] =	{
				name: 'AdOtsu', 		params: { window: 30, k: 1.02, R: 0.1 }, enum: algorithEnums.ADOTSU,
				date: 2010, title: 'A multi-scale framework for adaptive binarization of degraded document images', authors: 'Reza Farrahi Moghaddam, Mohamed Cheriet'};
			algorithms[algorithEnums.SU] =	{
				name: 'Su', 		params: { window: 9, minN: 9 }, enum: algorithEnums.SU,
				date: 2010, title: 'Binarization of Historical Document Images Using the Local Maximum and Minimum', authors: 'Bolan Su, Shijian Lu, and Chew Lim Tan'};
			algorithms[algorithEnums.TRSINGH] =	{
				name: 'T.R. Singh', params: { window: 75, k: 0.20 }, enum: algorithEnums.TRSINGH,
				date: 2011, title: 'A New local Adaptive Thresholding Technique in Binarization', authors: 'T. Romen Singh, Sudipta Roy, O. Imocha Singh, Tejmani Sinam, Kh. Manglem Singh'};
			algorithms[algorithEnums.BATAINEH] =	{
				name: 'Bataineh', params: { }, enum: algorithEnums.BATAINEH,
				date: 2011, title: 'An adaptive local binarization method for document images based on a novel thresholding method and dynamic windows', authors: 'Bilal Bataineh, Siti Norul Huda Sheikh Abdullah, Khairuddin Omar'};
			algorithms[algorithEnums.ISAUVOLA] =	{
				name: 'ISauvola', 	params: { window: 15, k: 0.01 }, enum: algorithEnums.ISAUVOLA,
				date: 2016, title: 'ISauvola: Improved Sauvola’s Algorithm for Document Image Binarization', authors: 'Zineb Hadjadj, Abdelkrimo Meziane, Yazid Cherfa, Mohamed Cheriet, Insaf Setitra'};
			algorithms[algorithEnums.WAN] =	{
				name: 'Wan', 		params: { window: 75, k: 0.20 }, enum: algorithEnums.WAN,
				date: 2018, title: 'Binarization of Document Image Using Optimum Threshold Modification', authors: 'Wan Azani Mustafa, Mohamed Mydin M. Abdul Kader'};
		
			let options = "";
			algorithms.forEach(function(alg) {
				options += "<option value='" + alg.enum + "'>" + alg.name + "</option>";
			});
			
			document.getElementById('algorithm').innerHTML = options;
		}

    </script>
    <script type="text/javascript" src="doxaWasm.js"></script>
	<script type="text/javascript" src="doxa.js"></script>
	<script>
		async function initialize() {
		    // Initialize the Doxa framework
            const algorithmEnums = await Doxa.initialize();

			// Create our algorithms selection list
			loadAlgorithms(algorithmEnums);

			// Setup canvas and get a Doxa Image out of it
			srcCanvas = document.getElementById('sourceCanvas');
			dstCanvas = document.getElementById('binaryCanvas');
			gtCanvas = document.getElementById('groundTruthCanvas');
			
			await loadCanvas(srcCanvas, '../Images/2JohnC1V3.png');
			srcImage = readCanvas(srcCanvas);

			// Convert the color image to binary and show on the Canvas
			selectAlgorithm(algorithmEnums.OTSU);

			// Initialize the comparison code for the image slider
			initComparisons();

			// Display
			document.getElementById("loader").style.display = "none";
			document.getElementById("workspace").style.visibility = "visible";
		}
		
		initialize();
	</script>
  </body>
</html>


